---
title: "Self-Paced Reading Task: Data Analysis"
author: "Víctor López Domínguez"
date: "3/05/2025"
output:
    html_document:
        theme: lumen
        highlight: espresso
---

### Research Questions and Predictions

**Research questions**:

1. Are object relative clauses (ORs) parsed slower than subject relative clauses (SRs) by adult Spanish-English bilinguals?

2. If so, does number mismatch between the two determiner phrases (DPs) facilitate their comprehension?

**Predictions**:

1. Adult Spanish-English bilinguals will show shorter reaction times (RTs) in SRs than in ORs.

2. Number mismatch between the two DPs will result in shorter RTs in ORs than number match.

### 0. Loading Libraries

The following libraries are imported:

1. `tidyverse`, for cleaner data wrangling functions and access to other included packages, such as `ggplot2`.
2. `ggthemes`, to access the theme `theme_calc()`.
3. `lmerTest`, for more powerful mixed regression models.
4. `gt`, for table creation functions.
5. `broom.mixed`, for converting model output into data frames.

```{r setup, message=FALSE}
library(tidyverse)
library(lmerTest)
library(ggthemes)
library(gt)
library(broom.mixed)
```

### 1. Importing and Cleaning Participant Data

```{r Part data import}
df_part <- read.csv("./data/part_data.csv")
summary(df_part)
```

```{r Part data cleaning}
df_part <- df_part %>%
    select(part_experiment, part_id, part_lang, part_impaired., part_abroad, part_certificate, part_cat_exp, part_cat_pro, part_spa_exp, part_spa_pro, part_eng_exp, part_eng_pro, part_eng_onset_time) %>%
    mutate(
        part_experiment = as.factor(part_experiment),
        part_id = as.factor(part_id),
        part_lang = as.factor(part_lang),
        part_impaired. = as.factor(part_impaired.),
        part_abroad = as.factor(part_abroad),
        part_certificate = as.factor(part_certificate),
        part_cat_exp = as.factor(part_cat_exp),
        part_cat_pro = as.factor(part_cat_pro),
        part_spa_exp = as.factor(part_spa_exp),
        part_spa_pro = as.factor(part_cat_pro),
        part_eng_exp = as.factor(part_eng_exp),
        part_eng_pro = as.factor(part_eng_pro)
    ) %>%
    filter(part_experiment == "TFG") %>%
    droplevels()

df_part$part_experiment <- NULL

summary(df_part)
```

## 2. Importing and Cleaning Task Data

First, an example is imported to inspect the data set's variables and their data types.

```{r Task data example}
df_example <- read.csv("./data/32.csv")
summary(df_example)
```

Having done this, now we know which are the specific names of each variable, which ones are of interest and the data type of their values.

We can now proceed to creating the full data set will all our participants' data. This is done by importing them and passing them through the `reduce()` function, which combines all the CSV files into a single data set. The keyword `rbind` makes sure that the individual data sets are merged as additional rows.

Note that only the following columns are selected:

- `part_id`, for the participants' ID number.
- `task`, for the kind of trial, item or question.
- `item_number`, for the items' ID number.
- `item_type`, for the type of item, experimental, practice or filler.
- `clause_type`, for the type fo clause, OR or SR.
- `number`, for the number condition, singular-singular (SS), plural-plural (PP), singular-plural (SP) or plural-singular (PS).
- `segment`, for the segment ID.
- `rt`, for the RTs.
- `correct`, for the accuracy of their responses to question tasks.

```{r Task data import}
df_raw <- reduce(
    list(
        select(read.csv("./data/29.csv"), part_id, task, item_number, item_type, clause_type, number, segment, rt, correct),
        select(read.csv("./data/31.csv"), part_id, task, item_number, item_type, clause_type, number, segment, rt, correct),
        select(read.csv("./data/32.csv"), part_id, task, item_number, item_type, clause_type, number, segment, rt, correct)
    ),
    rbind
)
summary(df_raw)
```

After that, the data is cleaned.

Firstly, the rows are ordered by the participants' ID number with the `order()` function.

Secondly, the observations are filtered using the `filter()` function, keeping only those that involve experimental items and excluding question tasks.

Then, the function `mutate()` is used to transform the data types. `item_number` is transformed to numeric. The rest are transformed to factors.

Additionally, a new column `matching` is created which groups match and mismatch conditions.

Lastly, the `relocate()` function is used to make the `matching` column follow the `number` one.

```{r Task data cleaning}
df_clean <- df_raw %>%
    .[order(.$part_id), ] %>%
    filter(.$item_type == "exp_item" & .$task == "item" & segment != "s0") %>%
    mutate(
        item_number = as.numeric(item_number),
        task = as.factor(task),
        item_type = as.factor(item_type),
        clause_type = as.factor(clause_type),
        number = as.factor(number),
        matching = as.factor(ifelse(number == "ss" | number == "pp", "match", "mismatch")),
        segment = as.factor(segment),
        part_id = as.factor(part_id),
    ) %>%
    relocate(matching, .after = number) %>%
    droplevels()
summary(df_clean)
```

With the data looking like it should, now it is time to check for normal distribution. A plot is created that holds the data as it is.

```{r Skewed data plot}
skewed_plot <- df_clean %>%
    ggplot(aes(x = rt)) +
    geom_density() +
    theme_calc()
skewed_plot
```

The first strategy to normalize the data is removing extreme values, or outliers, which might be causing the data to be left-skewed.

```{r Skewed data with no outliers}
q1 <- quantile(df_clean$rt, 0.25)
q3 <- quantile(df_clean$rt, 0.75)
iqr <- q3 - q1
lower_limit <- q1 - iqr * 1.5
upper_limit <- q3 + iqr * 1.5

df_clean <- df_clean %>%
    filter(.$rt > lower_limit & .$rt < upper_limit)

no_outlier_plot <- df_clean %>%
    ggplot(aes(x = rt)) +
    geom_density() +
    theme_calc()
no_outlier_plot
```

A second strategy that can be performed to further normalize the data is converting the continuos variable, RTs, into a logarithmic scale.

```{r Logged and normalized data}
df_clean <- df_clean %>%
    mutate(rt = log(rt))

normal_plot <- df_clean %>%
    ggplot(aes(x = rt)) +
    geom_density() +
    theme_calc()
normal_plot
```

Now, with both the participant and task data being cleaned, they are merged.

```{r Merged data sets}
df_part$part_experiment <- NULL

df_merged <- merge(df_clean, df_part, by = "part_id")
summary(df_merged)
```

### 2. Linear Models

Three regression models are created using the `lmer()` function.

- `lm_clause` checks for the correlation between RTs and clause type. Significantly higher RTs are expected for ORs.
- `lm_matching` checks for the interaction between clause type and matching on RTs. A significant effect of mismatch condition is expected in ORs but not in SRs.
- `lm_segment` checks for the interaction between clause type and segment on RTs. A significant effect of clause type is expected in segments 3, 4 and 5. The rest are filtered out.

#### RQ1: Effects of Clause Type

```{r LM of clause type effects}
lm_clause <- lmer(data = df_merged, rt ~ clause_type + (1 | part_eng_pro) + (1 | part_eng_exp) + (1 | part_eng_onset_time))
summary(lm_clause)
```

```{r LM of clause type effects by segment}
lm_segment <- lmer(data = df_merged, rt ~ clause_type * segment + (1 | part_eng_pro) + (1 | part_eng_exp))
summary(lm_segment)
```

#### RQ2: Effects of Number

```{r LM of number effects}
lm_matching <- lmer(data = df_merged, rt ~ clause_type * matching + (1 | part_eng_exp) + (1 | part_eng_pro))
summary(lm_matching)
```

## 3. Data Visualization

#### RQ1: Effects of Clause Type

```{r}
lm_clause_plot <- df_clean %>%
    ggplot(aes(y = rt, x = clause_type, color = clause_type)) +
    geom_boxplot(show.legend = FALSE, staplewidth = 0.5, notch = TRUE) +
    theme_calc()
lm_clause_plot
```

```{r}
lm_segment_plot <- df_clean %>%
    filter(segment %in% c("s3", "s4", "s5")) %>%
    ggplot(aes(y = rt, x = segment, color = segment)) +
    facet_wrap(~clause_type) +
    geom_boxplot(notch = TRUE, staplewidth = 0.5, show.legend = FALSE) + # Change notch to TRUE
    theme_calc()
lm_segment_plot
```

```{r}
lm_segment_plot2 <- df_clean %>%
    # filter(segment %in% c("s3", "s4", "s5")) %>%
    ggplot(aes(y = rt, x = segment, color = clause_type, group = clause_type)) +
    stat_summary(fun = mean, geom = "line") +
    stat_summary(fun = mean, geom = "point") +
    theme_calc()
lm_segment_plot2
```

#### RQ2: Effects of Number

```{r}
lm_matching_plot <- df_clean %>%
    ggplot(aes(y = rt, x = matching, color = matching, group = matching)) +
    geom_boxplot(notch = TRUE, staplewidth = 0.5, show.legend = FALSE) +
    facet_wrap(df_clean$clause_type) +
    theme_calc()
lm_matching_plot
```

```{r}
lm_matching_plot2 <- df_clean %>%
    ggplot(aes(y = rt, x = segment, color = matching, group = matching)) +
    stat_summary(fun = mean, geom = "line") +
    stat_summary(fun = mean, geom = "point") +
    facet_wrap(df_clean$clause_type) +
    theme_calc()
lm_matching_plot2
```
